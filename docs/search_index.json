[
["index.html", "Intermediate R Workshop 1 Preamble", " Intermediate R Workshop David Wilkinson 2020-02-04 1 Preamble This is the course notes for an Intermediate R Workshop run by David Wilkinson. This workshop will cover aspects of control flow life if statements and for loops, as well as writing custom functions. This material has been adapted with permission from Research Platforms Services’s own Introductory R Workshop course material. "],
["technical-requirements.html", "2 Technical Requirements", " 2 Technical Requirements All attendees will be required to bring their own laptop and charger. Tablets and/or Chromebooks (or similar) are not recommended. It can have a Windows, Mac, or Linux operating system, but you must have administrative privileges. Attendees are also asked to install both R and RStudio in advance of the workshop. Both R and RStudio are updated regularly with both new features and bug fixes, so we require attendees to have R v3.6 or later, and RStudio v1.2 or later. "],
["dataset.html", "3 Dataset", " 3 Dataset For this workshop we will be using a dataset on passengers from the Titanic. It can be loaded like so: titanic &lt;- read.csv(&quot;https://goo.gl/4Gqsnz&quot;) "],
["project-set-up.html", "4 Project Set-up 4.1 Introduction 4.2 Directory structures 4.3 R Projects 4.4 Code script structures 4.5 Code style guides", " 4 Project Set-up 4.1 Introduction Before we jump in to coding in R we’re going to establish some programming best practices. These will not only make your programming experience proceed more smoothly, but most importantly you will thank yourself in six months for adopting them now when you have to revisit an older script and have to figure out what you did, how you did it, and why you did it that way. 4.2 Directory structures It is best to keep all files associated with a given project (like a PhD chapter) located in a single root folder. This is commonly called a “one folder, one project” mentality, and has multiple benefits including: Easy communication with collaborators (particularly in a version controlled environment) A clear, easily navigable directory structure makes finding specific files easier You don’t accidentally lose an important file for your analysis because you kept it somewhere else That said, there is no single best way to organise a file system. The key is to make sure that your chosen directory structure and the location of the files therein is consistent, informative, and, most importantly, works for you. An example directory structure (for a MyProject root directory) might include the following: A data folder that contains all input data (and associated metadata) for the analysis. This is then potentially split further into: A raw folder for your raw data files. These should never be modified so it is best to keep them separate. A clean folder for your cleaned up versions of your raw data files. A doc or reports folder for any manuscripts. This can include the manuscript submitted to a journal for publication, reports for a funding body like a government or NGO, or some markdown files documenting the steps of the analysis. You may wish to sub-divide this folder to include these different types or, alternatively, include both a docs and reports folder A figs or images folder for any graphs and figures generated in the analysis An output folder to store any type of intermediate or output files. This could include model objects, simulations, etc. Some people prefer to store their cleaned data here instead of in a sub-directory of data A scripts folder to store the code scripts used in the analysis ################### ### Challenge 1 ### ################### # Build your own project directory structure for this workshop. For our purposes today you will require at least a `data`, `scripts`, and `images` folder 4.3 R Projects R builds on the “one folder, one project” mentality with the creation of R Projects. An R Project serves as a self-contained environment for your entire analysis. Amongst other things, the benefits of an R Project are: Relative file paths. The path to a file now only needs to be specified relative to the R project root directory. No more file paths going off the screen! Maintain your environment between sessions. Normally, unless explicitly saved to file and re-loaded, your environment is lost between sessions. This means re-running your code again and again, which is infeasible for larger analysis that may take hours or days to run. An R project will automatically save and re-load your environment. Easy collaboration. A combination of the two above points means that you can send an R project directory to a colleague and the whole thing will run with no issue. This would otherwise require, at minimum, manually changing all file paths. Version control. RStudio has an in-built point-and-click git interface that is only accessible when using an R Project. You can either start an R Project from scratch by creating a new directory, or add R Project functionality to an existing directory. You can create an R Project from either the File menu in the top left of the screen, or from the Project menu in the top right. ################### ### Challenge 2 ### ################### # Add an `R Project` to the existing directory you created in Challenge 1. 4.4 Code script structures A script is essentially a text file that R recognises as containing R code and providing it with syntax highlighting. You can run R commands in the Console, but there is no way of saving the commands you’ve used for future reference. Instead you can enter your commands in a script file to save them like any other document. Much like for directories, it is important to structure your code scripts. Without structure it is extremely difficult to return to an old script and figure out what you’ve done. Just like there is no single correct way of structuring a directory, there is no single correct way of structuring a script. It is up to you to settle on a structure that works for you. Some things to consider using: A title and “script abstract” at the top of the script saying what the script is for and how it does it. Use headings/subheadings to make navigating between sections easier. These will obviously depend on what the script is doing, but common ones include Load Packages, Load Data, Data Manipulation, Model Fitting, Plotting, and Save Outputs. Have any loaded packages called at the beginning of the script. This avoids some of the issues that may arise from function masking, and makes it easy for anyone else using the script to identify the packages they need to install. Comment your code! Add comments to your code to remind you not only what you’ve done but why you’ve done it that way. If you come back to a script from six months ago it will be much easier to remember what you’ve done. 4.5 Code style guides Another thing that makes reading a code script easier is the use of a style guide. A style guide is essentially a series of self-imposed grammar/syntax rules to follow to write neat and human-readable code. Two commonly adopted ones are Google’s R style guide and Hadley Wickham’s R style guide. You can also define your own by picking and choosing rules from different places. Some common things to consider: Naming conventions. Be consistent with how you name variables, functions, etc. Many people implement a different style for variables and functions to help tell them apart. Some options are: camelCase PascalCase / UpperCamelCase snake_case snake.case.variant ALL_CAPS (normally reserved for constants) &lt;- instead of = for variable assignment A line length of &lt;80 characters. This is more of a rule of thumb not hard and fast, but the idea is to keep from having to scroll across to read a full command Whitespace. R will ignore all whitespace in your code except for between a function name and it’s opening parenthesis i.e. mean (1,2), and inside object names. Make use of it to make the code readable (e.g. on either side of an operator 1 + 2) but don’t add it in unnecessarily. Multi-line function calls. R recognises that a function call is not finished if the line ends in a comma, so you can add each argument in a function to a new line to make it fit on a page. E.g. sum(1:100, na.rm = TRUE) "],
["conditionals.html", "5 Conditionals 5.1 if statements 5.2 if else statements 5.3 The ifelse() function 5.4 Challenge Answers", " 5 Conditionals One aspect of control flow is controlling when and how parts of our code run. This is done by setting actions (or lines of code) to only run when certain conditions are met. In R this is handled by a group of functions under the if statements banner. 5.1 if statements The basic if statement follows the following syntax: if(condition is met){ do this } There are three components to an if statement: The if special R function. The condition to be tested. The code to be evaluated if the condition is met. In other words, “if this is true do this”. A basic example: x &lt;- 5 if(x &gt; 0){ print(&quot;x is a positive number&quot;) } ## [1] &quot;x is a positive number&quot; ################### ### CHALLENGE 1 ### ################### Use an if statement to print a suitable message reporting whether there are any people with age of &gt;100 in the titanic dataset. Now do the same for &gt;70. HINT: you will need to use the na.rm argument in the any() function. 5.2 if else statements So far we’ve seen code that triggers if the condition is met, but what about if we want to trigger something different if the condition is not met? This is where the else statement works in conjunction with the if statement: x &lt;- 5 if(x &lt; 0){ print(&quot;x is less than zero&quot;) } else { print(&quot;x is greater than or equal to zero&quot;) } ## [1] &quot;x is greater than or equal to zero&quot; What if you have more than a two category condition? Instead of “if true do this” we might have “if A do this, if B do this, if C do this”. x &lt;- 5 if(x &lt; 0){ print(&quot;x is less than zero&quot;) } else if(x == 0){ print(&quot;x equals zero&quot;) } else if(x &gt; 0){ print(&quot;x is greater than zero&quot;) } ## [1] &quot;x is greater than zero&quot; ################### ### CHALLENGE 2 ### ################### Randomly sample one passenger from the titanic dataset. Then construct an if else statement to print a message about whether the passenger is younger than 20, between 20 and 50, or over 50 years old. 5.3 The ifelse() function You may have noticed that the if statement performs a single test. This means that you can’t apply it repeatedly over an R object like a vector. The ifelse() function is vectorised so it can handle vector inputs. The three inputs to this function are the test to be applied to each element of the vector, the code to happen if the test returns TRUE (yes), and the code to happen if the test returns FALSE (no). x &lt;- 1:10 ifelse(test = x %% 2 == 0, yes = &quot;even&quot;, no = &quot;odd&quot;) ## [1] &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;even&quot; &quot;odd&quot; ## [10] &quot;even&quot; ################### ### CHALLENGE 3 ### ################### Add a new column to the titanic dataset called &quot;Adult&quot; that is a binary variable indicating whether that passenger is an 18 or older. 5.4 Challenge Answers ################### ### Challenge 1 ### ################### if(any(titanic$Age &gt; 100, na.rm = TRUE)){ print(&quot;There are passengers older than 100&quot;) } if(any(titanic$Age &gt; 70, na.rm = TRUE)){ print(&quot;There are passengers older than 70&quot;) } ################### ### CHALLENGE 2 ### ################### passenger &lt;- titanic[sample(1:nrow(titanic), 1), ] if(is.na(passenger$Age)){ print(&quot;The passenger has no recorded age&quot;) } else if(passenger$Age &lt; 20){ print(&quot;The passenger is less than 20 years old&quot;) } else if(passenger$Age &gt;= 20 &amp; &lt;= 50){ print(&quot;The passenger is between 20 and 50 years old&quot;) } else if(passenger$Age &gt; 50){ print(&quot;The passenger is greater than 50 years old&quot;) } ################### ### CHALLENGE 3 ### ################### titanic$Adult &lt;- ifelse(titanic$Age &lt; 18, yes = 0, no = 1) "],
["loops.html", "6 Loops 6.1 for loops 6.2 while loops 6.3 Challenge Answers", " 6 Loops The second aspect of control flow is being able to repeat the same set of operations for a series of inputs. This is achieved by using loops to iteratively repeat your code until some condition is met. There are two types of loops in R: for loops and while loops. The most common is for loops where you repeat your code for each element in a series of inputs. while loops will repeat over the same set of code while a condition is met. 6.1 for loops The basic syntax of a for loop is this: for(iterator in some_things){ do this } A basic example: for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ################### ### CHALLENGE 4 ### ################### For each of the passenger classes in the titanic dataset calculate the mean survival rate of that class 6.1.1 Nested for loops For situations where you need to loop over the different combinations of multiple iterators you can nest for loops within each other. For example: for(i in 1:5){ for(j in c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)){ print(paste(i, j)) } } ## [1] &quot;1 a&quot; ## [1] &quot;1 b&quot; ## [1] &quot;1 c&quot; ## [1] &quot;1 d&quot; ## [1] &quot;1 e&quot; ## [1] &quot;2 a&quot; ## [1] &quot;2 b&quot; ## [1] &quot;2 c&quot; ## [1] &quot;2 d&quot; ## [1] &quot;2 e&quot; ## [1] &quot;3 a&quot; ## [1] &quot;3 b&quot; ## [1] &quot;3 c&quot; ## [1] &quot;3 d&quot; ## [1] &quot;3 e&quot; ## [1] &quot;4 a&quot; ## [1] &quot;4 b&quot; ## [1] &quot;4 c&quot; ## [1] &quot;4 d&quot; ## [1] &quot;4 e&quot; ## [1] &quot;5 a&quot; ## [1] &quot;5 b&quot; ## [1] &quot;5 c&quot; ## [1] &quot;5 d&quot; ## [1] &quot;5 e&quot; ################### ### CHALLENGE 5 ### ################### For each combination of passenger class and sex in the titanic dataset calculate the mean survival rate 6.1.2 Growing outputs A strength of loops is that we can use them to perform the same analysis over and over. However there are two ways of storing the output. The first is known as the balloon method and involves continually expanding the size of your output. For example: output_vector &lt;- c() for(i in 1:10){ output_vector &lt;- c(output_vector, sample(1:5, 1)) print(output_vector) } ## [1] 1 ## [1] 1 3 ## [1] 1 3 3 ## [1] 1 3 3 1 ## [1] 1 3 3 1 4 ## [1] 1 3 3 1 4 5 ## [1] 1 3 3 1 4 5 4 ## [1] 1 3 3 1 4 5 4 3 ## [1] 1 3 3 1 4 5 4 3 3 ## [1] 1 3 3 1 4 5 4 3 3 2 The alternative is the bottle method which involves creating an empty output of the correct size and then filling it piece by piece. The balloon method is easier to set up but the bottle method is more computationally efficient as it does not involve re-writing the output everytime you add to it. For example: output_vector &lt;- rep(0, 10) for(i in 1:10){ output_vector[i] &lt;- sample(1:5, 1) print(output_vector) } ## [1] 5 0 0 0 0 0 0 0 0 0 ## [1] 5 3 0 0 0 0 0 0 0 0 ## [1] 5 3 4 0 0 0 0 0 0 0 ## [1] 5 3 4 4 0 0 0 0 0 0 ## [1] 5 3 4 4 1 0 0 0 0 0 ## [1] 5 3 4 4 1 3 0 0 0 0 ## [1] 5 3 4 4 1 3 5 0 0 0 ## [1] 5 3 4 4 1 3 5 2 0 0 ## [1] 5 3 4 4 1 3 5 2 2 0 ## [1] 5 3 4 4 1 3 5 2 2 1 ################### ### CHALLENGE 6 ### ################### Use the system.time() function to compare how long it takes to use the balloon and bottle methods to create a vector 10,000 elements long 6.2 while loops while loops have a more niche application, but are really useful for when you don’t know how long it will take you to get to the end. A great application example is population viability simulations where you keep progressing through time until the population dies out. The basic syntax looks life this: while(condition is true){ do this } For example: x &lt;- 10 while(x &gt; 0){ x &lt;- x - 1 print(x) } ## [1] 9 ## [1] 8 ## [1] 7 ## [1] 6 ## [1] 5 ## [1] 4 ## [1] 3 ## [1] 2 ## [1] 1 ## [1] 0 ################### ### CHALLENGE 7 ### ################### Use a while loop to simulate a population decline. Start with a population of 100 and then use the sample() function to have it decline between 1-5 individuals per time step. 6.3 Challenge Answers ################### ### CHALLENGE 4 ### ################### for(class in unique(titanic$Pclass)){ mean_surv &lt;- mean(titanic[titanic$Pclass == class, &quot;Survived&quot;], na.rm = TRUE) print(paste(&quot;The mean survival rate of class&quot;, class, &quot;was&quot;, mean_surv)) } ################### ### CHALLENGE 5 ### ################### for(class in unique(titanic$Pclass)){ for(sex in unique(titanic$Sex)){ mean_surv &lt;- mean(titanic[titanic$Pclass == class &amp; titanic$Sex == sex, &quot;Survived&quot;], na.rm = TRUE) print(paste(&quot;The mean survival rate of&quot;, sex, &quot;passengers in class&quot;, class, &quot;was&quot;, mean_surv)) } } ### Balloon method output_vector &lt;- c() system.time( for(i in 1:10000){ output_vector &lt;- c(output_vector, 1) } ) ### Bottle Method output_vector &lt;- vector(length = 10000) system.time( for(i in 1:10000){ output_vector[i] &lt;- 1 } ) ################### ### CHALLENGE 7 ### ################### population &lt;- 100 while(population &gt; 0){ population &lt;- population - sample(1:5, 1) print(population) } "],
["functions.html", "7 Functions 7.1 What is a function? 7.2 Function structure 7.3 Define our own function 7.4 Nesting functions 7.5 Applying functions to datasets 7.6 Challenge Answers", " 7 Functions 7.1 What is a function? Functions let us repeat several operations with a single command. This is useful when we want to apply the same process exactly to different inputs, as we only need to define the process (i.e. write the code) once rather than for each input. In fact, almost everything we’ve already covered today is a function. Functions provide: A name we can remember and invoke it by A relief from the need to remember individual operations A defined set of expetected inputs and outputs Rich connections to a larger programming environment 7.2 Function structure All functions in R follow a set structure. They require a name, a list of inputs called an arglist, and the desired processes defined in the body. name &lt;- function(arglist){ body } We can see how existing functions in R are defined by typing the function name in the console without brackets, or by highlighting the function name and pressing F2. Here is the definition of the upper.tri() function: upper.tri ## function (x, diag = FALSE) ## { ## d &lt;- dim(x) ## if (length(d) != 2L) ## d &lt;- dim(as.matrix(x)) ## if (diag) ## .row(d) &lt;= .col(d) ## else .row(d) &lt; .col(d) ## } ## &lt;bytecode: 0x0000016c5593f4c0&gt; ## &lt;environment: namespace:base&gt; 7.3 Define our own function Now lets define our own function. There is already a function called sum() in R, but addding two numbers together is a simple process and serves as a useful example. Here we define a function called mySum() that will return the sum of two input values a and b. mySum &lt;- function(a, b){ value &lt;- a + b return(value) } Functions can be as simple or complex as required. Converting temperature values between different units of measure is possible with the use of formulas. Rather than having to apply the formula each time we want to make the conversion, defining it as a function would make things much easier. Now we can define a function for converting temperatures in fahrenheit to kelvin: fahr_to_kelvin &lt;- function(temp){ kelvin &lt;- ((temp - 32) * (5 / 9)) + 273.15 return(kelvin) } Now lets test it: fahr_to_kelvin(32) ## [1] 273.15 ################### ### CHALLENGE 8 ### ################### Write your own function to convert temperatures from kelvin to celsius. Hint: to convert from kelvin to celsius subtract 273.15 7.4 Nesting functions The real power of functions comes from the ability to mix, match, and combine them into ever larger chunks to get the effect we want. In fact, the vast majority of functions in R make use of nested functions. If we look at the upper.tri() function again, we can see that it uses a combination of as.matrix(), row(), and col(). upper.tri ## function (x, diag = FALSE) ## { ## d &lt;- dim(x) ## if (length(d) != 2L) ## d &lt;- dim(as.matrix(x)) ## if (diag) ## .row(d) &lt;= .col(d) ## else .row(d) &lt; .col(d) ## } ## &lt;bytecode: 0x0000016c5593f4c0&gt; ## &lt;environment: namespace:base&gt; ################### ### CHALLENGE 9 ### ################### Using the two functions we&#39;ve defined to convert fahrenheit to kelvin, and kelvin to celsius, define a function that converts fahrenheit to celsius. 7.5 Applying functions to datasets Here we define a function that calculates the average age in a dataset (in our case, the titanic dataset). calcAgeAverage &lt;- function(dat){ ageAverage &lt;- mean(dat$Age, na.rm = TRUE) return(ageAverage) } Now to test it: calcAgeAverage(titanic) ## [1] 29.69912 Now we can add an additional argument to the function so that we can find the average age by gender: calcAgeAverage &lt;- function(dat, sex = &quot;female&quot;){ ageAverage &lt;- mean(dat[dat$Sex == sex, ]$Age, na.rm = TRUE) return(ageAverage) } And test it: calcAgeAverage(titanic, sex = &quot;female&quot;) ## [1] 27.91571 calcAgeAverage(titanic, sex = &quot;male&quot;) ## [1] 30.72664 calcAgeAverage(titanic) ## [1] 27.91571 #################### ### CHALLENGE 10 ### #################### Define the function to calculate the average age for specific classes of a single sex. Hint: Look up the function %in%, which will allow you to subset by multiple classes. 7.6 Challenge Answers ################### ### CHALLENGE 8 ### ################### kelvin_to_celsius &lt;- function(temp){ celsius &lt;- temp - 273.15 return(celsius) } ################### ### CHALLENGE 9 ### ################### fahr_to_celsius &lt;- function(temp){ kelvin &lt;- fahr_to_kelvin(temp) celsius &lt;- kelvin_to_celsius(kelvin) return(celsius) } #################### ### CHALLENGE 10 ### #################### calcAgeAverage &lt;- function(dat, sex, class){ ageAverage &lt;- mean(dat[dat$Sex == sex &amp; dat$Pclass %in% class, ]$Age, na.rm = TRUE) return(ageAverage) } "]
]
